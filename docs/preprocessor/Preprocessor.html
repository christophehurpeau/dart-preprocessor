        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Preprocessor class / preprocessor Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="preprocessor" data-type="Preprocessor">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../preprocessor.html">preprocessor</a> &rsaquo; <a href="../preprocessor/Preprocessor.html">Preprocessor</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Preprocessor</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Preprocessor {
 String _type;
 Function _pathResolver;
 MultiRegExp _multiRegExp;

 static final List&lt;String&gt; types = [
     'js', 'php', 'dart',
     'css', 'less', 'styl', 'scss',
   ];

 static final List&lt;String&gt; singleLinesSupportedTypes = [
     'js', 'php', 'dart',
     'less', 'styl', 'scss'
 ];

 static final int errorSourceAhead = 50;
 static final RegExp regExpIfThen = new RegExp(r'^(.*) then (.*)$');

 Preprocessor(String this._type, [ Function this._pathResolver ]){
   var EXPR_INSTRUCTIONS = '(include(?:Once)?|ifn?def|ifelse|if|\/if|endif|else|el(?:se)?if|eval|value|val|setbasedir)';

   var multilineRegExp = new RegExp(r'(^[ \t]*)?\/\*[ ]*#[ ]*' + EXPR_INSTRUCTIONS + r'([^\*]*)[ ]*\*\/', multiLine:true);
   var singlelineRegExp = new RegExp(r'(^[ \t]*)(?:\/\/)?#' + EXPR_INSTRUCTIONS + r'(.*)$', multiLine:true);

   Set&lt;RegExp&gt; regExps = new Set();
   regExps.add(multilineRegExp);
   if (singleLinesSupportedTypes.contains(_type)) {
     regExps.add(singlelineRegExp);
   }
   if (this._type == 'js') {
     regExps.add(new RegExp(r'''(^[ \t]*)?(include(?:Once)?)\('([^\)]*)'\)'''));
   }

   _multiRegExp = new MultiRegExp.fromIterable(regExps);
 }

 static String indent(String str, String indent){
   return str.split("\n").map((line) =&gt; indent + line).join("\n");
 }

 // TODO : process String instead of data. lines by lines. For multi lines things like if/else/elseif, we know if they should be included or not because we know if the condition is valid.
 Future&lt;String&gt; process(Map&lt;String, dynamic&gt; defines, String data) {
   assert(data != null);
   MutableString mutableData = new MutableString(data);

   Completer&lt;String&gt; completerPreprocessor = new Completer();
   Queue stack = new Queue(); // Queue is too sophisticated

   Future.forEach(mutableData.allMatchesFromMultiRegExp(this._multiRegExp), (MutableStringMatch match){
     var completer = new Completer&lt;String&gt;();
     String indent = match[1], instruction=match[2], content=match[3].trim();
     //print('Preprocessor, match: '+match[0]+'; instruction = '+ instruction + ', content = '+content+'; string='+mutableData.string);

     switch (instruction) {
       case 'eval':
         throw new Exception('instruction "eval" is not supported');
         break;
       case 'value': case 'val':
         String include = defines[content].toString();

         int removeAfterLength = 0;
         String first2=match.input.length &gt;= match.end +2 ? match.input.substring(match.end,match.end+2) : null;
         if(first2 != null &amp;&amp; first2=='0 ') removeAfterLength = 2;
         else if(first2 != null &amp;&amp; ['0;','0,','0)','0.','0+','0-'].contains(first2)) removeAfterLength = 1;
         else if(first2 != null &amp;&amp; first2=="''") removeAfterLength = 2;
         else if(match.input.length &gt;= match.end +5 &amp;&amp; match.input.substring(match.end,match.end+5)=='false') removeAfterLength = 5;
         else if(match.input.length &gt;= match.end +4 &amp;&amp; match.input.substring(match.end,match.end+4)=='true') removeAfterLength = 4;

         match.replacePart(match.start, match.end + removeAfterLength, include);
         completer.complete();
         break;

       case 'ifdef': case 'ifndef': case 'if': case 'ifelse':
         var include;
         if (instruction=='ifdef') {
           include = defines.containsKey(content);//!!defines[match2[2]];
         } else if (instruction=='ifndef') {
           include = !defines.containsKey(content);//!defines[match2[2]];
         } else if (instruction=='ifelse') {
           include = defines[content] ? 1 : 2;
         } else{
           Match ifThenMatch = regExpIfThen.firstMatch(content);
           if(ifThenMatch != null){
             include = defines[ifThenMatch[1]] ? ifThenMatch[2] : '';
             match.replacePart(match.start, match.end, include);
             completer.complete();
             break;
           }else if(content.endsWith('=&gt;')){ // if var =&gt; : then until the end of the line
             content = content.substring(0, content.length-2).trim();
             if(defines[content])
               match.replacePart(match.start,match.end);
             else
               match.replacePart(match.start,match.input.indexOf("\n",match.end));
           }else{
             if(content[0]=='!') include = !defines[content.substring(1).trim()];
             else include = defines[content];
           }
         }

         stack.add({ "include": include, "start": match.start, "end": match.end });
         completer.complete();
         break;

       case '/if': case 'endif': case 'else': case 'elif': case 'elseif':
         if (stack.length == 0)
           throw new Exception("Unexpected #"+instruction+": "+match.input.substring(match.start, Math.min(match.start + errorSourceAhead,match.input.length))+"...");

         var before = stack.removeFirst();
         var include = match.input.substring(before['end'], match.start);
         if (before['include'] == 1 || before['include'] == 2) {
           if (include[0]=='(' &amp;&amp; include.substring(include.length-1)==')') {
             include = include.substring(1,include.length-1);
           }
           include = include.split('||');
           if (include.length != 2) {
             return completer.completeError(new Exception('ifelse : '+include.length+' != 2 : '+include.join('||')));
           }
           include = include[before['include']-1];
         } else if (!before['include']) {
           include = '';
         }
         match.replacePart(before['start'], match.end, include);
         if (instruction == "else" || instruction == "elif" || instruction == "elseif") {
           if (instruction=='else'){
             include=!before['include'];
           } else if(content[0]=='!') {
             include = !defines[content.substring(1).trim()];
           } else {
             include = defines[content];
           }
           stack.add({ "include": !before["include"], "start": match.lastIndex, "lastIndex": match.lastIndex });
         }
         completer.complete();
         break;

       case 'include': case 'includeOnce':
         /*if(content.slice(-1) === '/') content += sysPath.basename(content) + '.js';
         else if(content.slice(-3) !== '.js') content += '.js';
         if(content.substr(0,1) !== '/') content = dirname + content;
         var path = (pathResolver||fs.realpathSync)(content);
         if(instruction === 'includeOnce' &amp;&amp; includedFiles.indexOf(path) !== -1){
           data = data.substring(0, match.index) + '' + data.substring(EXPR.lastIndex + removeAfterLength);
           onEnd();
         }else{
           includedFiles.push(path);
           fs.readFile(path,function(err,content){
             if(err) return onEnd(err);
             module.exports(defines, content, baseDir, includedFiles,function(err,include){
               if(err) return onEnd(err);
               data = data.substring(0, match.index) + content + data.substring(EXPR.lastIndex + removeAfterLength);
               onEnd();
             });
           });
         }*/
         completer.complete();
         break;

       default:
         completer.complete();
     }

     return completer.future;
   }).then((_){
       completerPreprocessor.complete(mutableData.string);
     }, onError: completerPreprocessor.completeError );
   return completerPreprocessor.future;
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="errorSourceAhead">
<button class="show-code">Code</button>
final int         <strong>errorSourceAhead</strong> <a class="anchor-link"
            href="#errorSourceAhead"
            title="Permalink to Preprocessor.errorSourceAhead">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final int errorSourceAhead = 50
</pre>
</div>
</div>
<div class="field"><h4 id="regExpIfThen">
<button class="show-code">Code</button>
final RegExp         <strong>regExpIfThen</strong> <a class="anchor-link"
            href="#regExpIfThen"
            title="Permalink to Preprocessor.regExpIfThen">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final RegExp regExpIfThen = new RegExp(r'^(.*) then (.*)$')
</pre>
</div>
</div>
<div class="field"><h4 id="singleLinesSupportedTypes">
<button class="show-code">Code</button>
final List&lt;String&gt;         <strong>singleLinesSupportedTypes</strong> <a class="anchor-link"
            href="#singleLinesSupportedTypes"
            title="Permalink to Preprocessor.singleLinesSupportedTypes">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final List&lt;String&gt; singleLinesSupportedTypes = [
   'js', 'php', 'dart',
   'less', 'styl', 'scss'
]
</pre>
</div>
</div>
<div class="field"><h4 id="types">
<button class="show-code">Code</button>
final List&lt;String&gt;         <strong>types</strong> <a class="anchor-link"
            href="#types"
            title="Permalink to Preprocessor.types">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final List&lt;String&gt; types = [
   'js', 'php', 'dart',
   'css', 'less', 'styl', 'scss',
 ]
</pre>
</div>
</div>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="indent">
<button class="show-code">Code</button>
String <strong>indent</strong>(String str, String indent) <a class="anchor-link" href="#indent"
              title="Permalink to Preprocessor.indent">#</a></h4>
<div class="doc">
<pre class="source">
static String indent(String str, String indent){
 return str.split("\n").map((line) =&gt; indent + line).join("\n");
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Preprocessor</strong>(String _type, [Function _pathResolver]) <a class="anchor-link" href="#"
              title="Permalink to Preprocessor.Preprocessor">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <code>Object</code> instance.</p>
<p><code>Object</code> instances have no meaningful state, and are only useful
through their identity. An <code>Object</code> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from Object </div></div>
<pre class="source">
Preprocessor(String this._type, [ Function this._pathResolver ]){
 var EXPR_INSTRUCTIONS = '(include(?:Once)?|ifn?def|ifelse|if|\/if|endif|else|el(?:se)?if|eval|value|val|setbasedir)';

 var multilineRegExp = new RegExp(r'(^[ \t]*)?\/\*[ ]*#[ ]*' + EXPR_INSTRUCTIONS + r'([^\*]*)[ ]*\*\/', multiLine:true);
 var singlelineRegExp = new RegExp(r'(^[ \t]*)(?:\/\/)?#' + EXPR_INSTRUCTIONS + r'(.*)$', multiLine:true);

 Set&lt;RegExp&gt; regExps = new Set();
 regExps.add(multilineRegExp);
 if (singleLinesSupportedTypes.contains(_type)) {
   regExps.add(singlelineRegExp);
 }
 if (this._type == 'js') {
   regExps.add(new RegExp(r'''(^[ \t]*)?(include(?:Once)?)\('([^\)]*)'\)'''));
 }

 _multiRegExp = new MultiRegExp.fromIterable(regExps);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="process">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>process</strong>(Map&lt;String, dynamic&gt; defines, String data) <a class="anchor-link" href="#process"
              title="Permalink to Preprocessor.process">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;String&gt; process(Map&lt;String, dynamic&gt; defines, String data) {
 assert(data != null);
 MutableString mutableData = new MutableString(data);

 Completer&lt;String&gt; completerPreprocessor = new Completer();
 Queue stack = new Queue(); // Queue is too sophisticated

 Future.forEach(mutableData.allMatchesFromMultiRegExp(this._multiRegExp), (MutableStringMatch match){
   var completer = new Completer&lt;String&gt;();
   String indent = match[1], instruction=match[2], content=match[3].trim();
   //print('Preprocessor, match: '+match[0]+'; instruction = '+ instruction + ', content = '+content+'; string='+mutableData.string);

   switch (instruction) {
     case 'eval':
       throw new Exception('instruction "eval" is not supported');
       break;
     case 'value': case 'val':
       String include = defines[content].toString();

       int removeAfterLength = 0;
       String first2=match.input.length &gt;= match.end +2 ? match.input.substring(match.end,match.end+2) : null;
       if(first2 != null &amp;&amp; first2=='0 ') removeAfterLength = 2;
       else if(first2 != null &amp;&amp; ['0;','0,','0)','0.','0+','0-'].contains(first2)) removeAfterLength = 1;
       else if(first2 != null &amp;&amp; first2=="''") removeAfterLength = 2;
       else if(match.input.length &gt;= match.end +5 &amp;&amp; match.input.substring(match.end,match.end+5)=='false') removeAfterLength = 5;
       else if(match.input.length &gt;= match.end +4 &amp;&amp; match.input.substring(match.end,match.end+4)=='true') removeAfterLength = 4;

       match.replacePart(match.start, match.end + removeAfterLength, include);
       completer.complete();
       break;

     case 'ifdef': case 'ifndef': case 'if': case 'ifelse':
       var include;
       if (instruction=='ifdef') {
         include = defines.containsKey(content);//!!defines[match2[2]];
       } else if (instruction=='ifndef') {
         include = !defines.containsKey(content);//!defines[match2[2]];
       } else if (instruction=='ifelse') {
         include = defines[content] ? 1 : 2;
       } else{
         Match ifThenMatch = regExpIfThen.firstMatch(content);
         if(ifThenMatch != null){
           include = defines[ifThenMatch[1]] ? ifThenMatch[2] : '';
           match.replacePart(match.start, match.end, include);
           completer.complete();
           break;
         }else if(content.endsWith('=&gt;')){ // if var =&gt; : then until the end of the line
           content = content.substring(0, content.length-2).trim();
           if(defines[content])
             match.replacePart(match.start,match.end);
           else
             match.replacePart(match.start,match.input.indexOf("\n",match.end));
         }else{
           if(content[0]=='!') include = !defines[content.substring(1).trim()];
           else include = defines[content];
         }
       }

       stack.add({ "include": include, "start": match.start, "end": match.end });
       completer.complete();
       break;

     case '/if': case 'endif': case 'else': case 'elif': case 'elseif':
       if (stack.length == 0)
         throw new Exception("Unexpected #"+instruction+": "+match.input.substring(match.start, Math.min(match.start + errorSourceAhead,match.input.length))+"...");

       var before = stack.removeFirst();
       var include = match.input.substring(before['end'], match.start);
       if (before['include'] == 1 || before['include'] == 2) {
         if (include[0]=='(' &amp;&amp; include.substring(include.length-1)==')') {
           include = include.substring(1,include.length-1);
         }
         include = include.split('||');
         if (include.length != 2) {
           return completer.completeError(new Exception('ifelse : '+include.length+' != 2 : '+include.join('||')));
         }
         include = include[before['include']-1];
       } else if (!before['include']) {
         include = '';
       }
       match.replacePart(before['start'], match.end, include);
       if (instruction == "else" || instruction == "elif" || instruction == "elseif") {
         if (instruction=='else'){
           include=!before['include'];
         } else if(content[0]=='!') {
           include = !defines[content.substring(1).trim()];
         } else {
           include = defines[content];
         }
         stack.add({ "include": !before["include"], "start": match.lastIndex, "lastIndex": match.lastIndex });
       }
       completer.complete();
       break;

     case 'include': case 'includeOnce':
       /*if(content.slice(-1) === '/') content += sysPath.basename(content) + '.js';
       else if(content.slice(-3) !== '.js') content += '.js';
       if(content.substr(0,1) !== '/') content = dirname + content;
       var path = (pathResolver||fs.realpathSync)(content);
       if(instruction === 'includeOnce' &amp;&amp; includedFiles.indexOf(path) !== -1){
         data = data.substring(0, match.index) + '' + data.substring(EXPR.lastIndex + removeAfterLength);
         onEnd();
       }else{
         includedFiles.push(path);
         fs.readFile(path,function(err,content){
           if(err) return onEnd(err);
           module.exports(defines, content, baseDir, includedFiles,function(err,include){
             if(err) return onEnd(err);
             data = data.substring(0, match.index) + content + data.substring(EXPR.lastIndex + removeAfterLength);
             onEnd();
           });
         });
       }*/
       completer.complete();
       break;

     default:
       completer.complete();
   }

   return completer.future;
 }).then((_){
     completerPreprocessor.complete(mutableData.string);
   }, onError: completerPreprocessor.completeError );
 return completerPreprocessor.future;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2014-02-10 17:33:12.523</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
